{"version":3,"file":"rete.min.js","sources":["../src/engine/component.ts","../src/node.ts","../src/component.ts","../src/connection.ts","../src/control.ts","../src/core/emitter.ts","../src/io.ts","../src/input.ts","../src/core/validator.ts","../src/core/context.ts","../src/view/utils.ts","../src/core/events.ts","../src/view/drag.ts","../src/view/zoom.ts","../src/view/area.ts","../src/view/connection.ts","../src/view/control.ts","../src/view/socket.ts","../src/view/node.ts","../src/view/index.ts","../src/selected.ts","../src/events.ts","../src/editor.ts","../src/output.ts","../src/socket.ts","../src/engine/recursion.ts","../src/engine/state.ts","../src/engine/events.ts","../src/engine/index.ts","../src/index.ts"],"sourcesContent":["import { Engine } from './index';\nimport { NodeData, WorkerInputs, WorkerOutputs } from '../core/data';\n\nexport abstract class Component {\n\n    name: string;\n    data: unknown = {};\n    engine: Engine | null = null;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    abstract worker(node: NodeData, inputs: WorkerInputs, outputs: WorkerOutputs, ...args: unknown[]): void;\n}","import { Connection } from './connection';\nimport { Control } from './control';\nimport { Input } from './input';\nimport { Output } from './output';\nimport { InputsData, NodeData, OutputsData } from './core/data';\n\nexport class Node {\n\n    name: string;\n    id: number;\n    position: [number, number] = [0.0, 0.0];\n    inputs = new Map<string, Input>();\n    outputs = new Map<string, Output>();\n    controls = new Map<string, Control>();\n    data: { [key: string]: unknown } = {};\n    meta: { [key: string]: unknown } = {};\n    collapsed: boolean;\n\n    descriptionCollapsed: boolean;\n    inputsCollapsed: boolean;\n    processedCollapsed: boolean;\n    outputsCollapsed: boolean;\n\n    static latestId = 0;\n\n    constructor(name: string) {\n        this.name = name;\n        this.collapsed = false;\n        this.descriptionCollapsed = true;\n        this.inputsCollapsed = false;\n        this.processedCollapsed = true;\n        this.outputsCollapsed = false;\n        this.id = Node.incrementId();\n    }\n\n    _add<T extends { key: string } & Record<string, any>>(list: Map<string, T>, item: T, prop: string) {\n        if (list.has(item.key))\n            throw new Error(`Item with key '${item.key}' already been added to the node`);\n        if (item[prop] !== null)\n            throw new Error('Item has already been added to some node');\n\n        (item as Record<string, Node>)[prop] = this;\n        list.set(item.key, item);\n    }\n\n    addControl(control: Control) {\n        this._add(this.controls, control, 'parent');\n        return this;\n    }\n\n    removeControl(control: Control) {\n        control.parent = null;\n\n        this.controls.delete(control.key);\n    }\n\n    addInput(input: Input) {\n        this._add(this.inputs, input, 'node');\n        return this;\n    }\n\n    removeInput(input: Input) {\n        input.removeConnections();\n        input.node = null;\n\n        this.inputs.delete(input.key);\n    }\n\n    addOutput(output: Output) {\n        this._add(this.outputs, output, 'node');\n        return this;\n    }\n\n    removeOutput(output: Output) {\n        output.removeConnections();\n        output.node = null;\n\n        this.outputs.delete(output.key);\n    }\n\n    setMeta(meta: { [key: string]: unknown }) {\n        this.meta = meta;\n        return this;\n    }\n\n    getConnections() {\n        const ios = [...this.inputs.values(), ...this.outputs.values()];\n        const connections = ios.reduce((arr, io) => {\n            return [...arr, ...io.connections];\n        }, [] as Connection[]);\n\n        return connections;\n    }\n\n    update() {\n    }\n\n    static incrementId() {\n        if (!this.latestId)\n            this.latestId = 1\n        else\n            this.latestId++\n        return this.latestId\n    }\n\n    static resetId() {\n        this.latestId = 0;\n    }\n\n    toJSON(): NodeData {\n        const reduceIO = <T extends Record<string, any>>(list: Map<string, Input | Output>) => {\n            return Array.from(list).reduce<T>((obj, [key, io]) => {\n                (obj as Record<string, any>)[key] = io.toJSON();\n                return obj;\n            }, {} as any)\n        }\n\n        return {\n            'id': this.id,\n            'data': this.data,\n            'inputs': reduceIO<InputsData>(this.inputs),\n            'outputs': reduceIO<OutputsData>(this.outputs),\n            'position': this.position,\n            'name': this.name,\n            'collapsed': this.collapsed,\n            'descriptionCollapsed':this.descriptionCollapsed,\n            'inputsCollapsed': this.inputsCollapsed,\n            'processedCollapsed': this.processedCollapsed,\n            'outputsCollapsed': this.outputsCollapsed\n        }\n    }\n\n    static fromJSON(json: NodeData) {\n        const node = new Node(json.name);\n        const [x, y] = json.position;\n\n        node.id = json.id;\n        node.data = json.data;\n        node.position = [x, y];\n        node.name = json.name;\n        Node.latestId = Math.max(node.id, Node.latestId);\n        node.collapsed = json.collapsed;\n        node.descriptionCollapsed = json.descriptionCollapsed;\n        node.inputsCollapsed = json.inputsCollapsed;\n        node.processedCollapsed = json.processedCollapsed;\n        node.outputsCollapsed = json.outputsCollapsed;\n\n        return node;\n    }\n}\n","import { Component as ComponentWorker } from './engine/component';\nimport { Node } from './node';\nimport { NodeEditor } from './editor';\n\nexport abstract class Component extends ComponentWorker {\n\n    editor: NodeEditor | null = null;\n    data: unknown = {};\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    abstract builder(node: Node): Promise<void>;\n\n    async build(node: Node) {\n        await this.builder(node);\n\n        return node;\n    }\n\n    async createNode(data = {}) {\n        const node = new Node(this.name);\n\n        node.data = data;\n        await this.build(node);\n\n        return node;\n    }\n}\n","import { Input } from './input';\nimport { Output } from './output';\n\nexport class Connection {\n\n    output: Output;\n    input: Input;\n    data: unknown = {};\n\n    constructor(output: Output, input: Input) {\n        this.output = output;\n        this.input = input;\n        this.data = {};\n\n        this.input.addConnection(this);\n    }\n\n    remove() {\n        this.input.removeConnection(this);\n        this.output.removeConnection(this);\n    }\n}","import { Input } from './input';\nimport { Node } from './node';\n\nexport class Control {\n\n    key: string;\n    data: unknown = {};\n    parent: Node | Input | null = null;\n\n    constructor(key: string) {\n        if (this.constructor === Control)\n            throw new TypeError('Can not construct abstract class');\n        if (!key)\n            throw new Error('The key parameter is missing in super() of Control ');\n\n        this.key = key;\n    }\n\n    getNode() {\n        if (this.parent === null)\n            throw new Error('Control isn\\'t added to Node/Input');   \n        \n        if (this.parent instanceof Node)\n            return this.parent;\n            \n        if (!this.parent.node)\n            throw new Error('Control hasn\\'t be added to Input or Node');\n\n        return this.parent.node;\n    }\n\n    getData(key: string) {\n        return this.getNode().data[key];\n    }\n\n    putData(key: string, data: unknown) {\n        this.getNode().data[key] = data;\n    }  \n}","import { Events } from './events';\n\nexport class Emitter<EventTypes> {\n\n    events: {[key: string]: Function[]} = {};\n    silent = false;\n\n    constructor(events: Events | Emitter<EventTypes>) {\n        this.events = events instanceof Emitter ? events.events : events.handlers;\n    }\n\n    on<K extends keyof EventTypes>(names: K | K[], handler: (args: EventTypes[K]) => void | unknown): this {\n        const events = names instanceof Array ? names : (names as string).split(' ');\n\n        (events as string[]).forEach(name => {\n            if (!this.events[name])\n                throw new Error(`The event ${name} does not exist`);\n            this.events[name].push(handler);\n        });\n\n        return this;\n    }\n\n    trigger<K extends keyof EventTypes>(name: K, params: EventTypes[K] | {} = {}) {\n        if (!(name in this.events))\n            throw new Error(`The event ${String(name)} cannot be triggered`);\n\n        return this.events[name as string].reduce((r: boolean, e: Function) => {\n            return (e(params) !== false) && r\n        }, true); // return false if at least one event is false\n    }\n\n    bind(name: string) {\n        if (this.events[name])\n            throw new Error(`The event ${name} is already bound`);\n\n        this.events[name] = [];\n    }\n\n    exist(name: string) {\n        return Array.isArray(this.events[name]);\n    }\n}\n","import { Connection } from './connection';\nimport { Node } from './node';\nimport { Socket } from './socket';\n\nexport class IO {\n\n    node: Node | null = null;\n    multipleConnections: boolean;\n    connections: Connection[] = [];\n   \n    key: string;\n    name: string;\n    socket: Socket;\n    data: any;\n\n    constructor(key: string, name: string, socket: Socket, multiConns: boolean) {\n\t    this.node = null;\n        this.multipleConnections = multiConns;\n        this.connections = [];\n\t   \n        this.key = key;\n        this.name = name;\n        this.socket = socket;\n    }\n    \n    removeConnection(connection: Connection) {\n        this.connections.splice(this.connections.indexOf(connection), 1);\n    }\n\n    removeConnections() {\n        this.connections.forEach(connection => this.removeConnection(connection));\n    }\n}","import { Connection } from './connection';\nimport { Control } from './control';\nimport { IO } from './io';\nimport { InputData } from './core/data';\nimport { Socket } from './socket';\n\nexport class Input extends IO {\n\n    control: Control | null = null;\n\n    constructor(key: string, title: string, socket: Socket, multiConns = false) {\n        super(key, title, socket, multiConns);\n    }\n\n    hasConnection() {\n        return this.connections.length > 0;\n    }\n\n    addConnection(connection: Connection) {\n        if (!this.multipleConnections && this.hasConnection())\n            throw new Error('Multiple connections not allowed');\n        this.connections.push(connection);\n    }\n\n    addControl(control: Control) {\n        this.control = control;\n        control.parent = this;\n    }\n\n    showControl() {\n        return !this.hasConnection() && this.control !== null;\n    }\n\n    toJSON(): InputData {\n        return {\n            'connections': this.connections.map(c => {\n                if (!c.output.node) throw new Error('Node not added to Output');\n\n                return {\n                    node: c.output.node.id,\n                    output: c.output.key,\n                    data: c.data\n                };\n            })\n        };\n    }\n}\n","import { Data } from './data';\n\nexport class Validator {\n\n    static isValidData(data: Data) {\n        return typeof data.id === 'string' &&\n            this.isValidId(data.id) &&\n            data.nodes instanceof Object && !(data.nodes instanceof Array);\n    }\n\n    static isValidId(id: string) {\n        return /^[\\w-]{3,}@[0-9]+\\.[0-9]+\\.[0-9]+$/.test(id);\n    }\n\n    static validate(id: string, data: Data) {\n        const id1 = id.split('@');\n        const id2 = data.id.split('@');\n        const msg = [];\n\n        if (!this.isValidData(data))\n            msg.push('Data is not suitable');\n        if (id !== data.id)\n            msg.push('IDs not equal');\n        if (id1[0] !== id2[0])\n            msg.push('Names don\\'t match');\n        if (id1[1] !== id2[1])\n            msg.push('Versions don\\'t match');\n\n        return { success: Boolean(!msg.length), msg: msg.join('. ') };\n    }\n}\n","import { Component } from '../engine/component';\nimport { Emitter } from './emitter'\nimport { Validator } from './validator'\nimport { EventsTypes as DefaultEvents, Events } from './events';\nimport { Plugin, PluginParams } from './plugin';\n\nexport class Context<EventsTypes> extends Emitter<EventsTypes & DefaultEvents> {\n\n    id: string;\n    plugins: Map<string, unknown>;\n    components: Map<string, Component>;\n\n    constructor(id: string, events: Events) {\n        super(events);\n\n        if (!Validator.isValidId(id))\n            throw new Error('ID should be valid to name@0.1.0 format');  \n        \n        this.id = id;\n        this.plugins = new Map();\n        this.components = new Map();\n    }\n\n    use<T extends Plugin, O extends PluginParams<T>>(plugin: T, options?: O) {\n        if (plugin.name && this.plugins.has(plugin.name)) throw new Error(`Plugin ${plugin.name} already in use`)\n\n        plugin.install(this, options || {});\n        this.plugins.set(plugin.name, options)\n    }\n\n    register(component: Component) {\n        if (this.components.has(component.name))\n            throw new Error(`Component ${component.name} already registered`);\n\n        this.components.set(component.name, component);\n        this.trigger('componentregister', component);\n    }\n\n    destroy() {\n        this.trigger('destroy');\n    }\n}","export function listenWindow<K extends keyof WindowEventMap>(event: K, handler: (e: WindowEventMap[K]) => void) {\n    window.addEventListener(event, handler);\n\n    return () => {\n        window.removeEventListener<K>(event, handler);\n    }\n}\n","import { Component } from '../engine/component';\n\nexport class Events {\n\n    handlers: {};\n\n    constructor(handlers: {}) {\n        this.handlers = {\n            warn: [console.warn],\n            error: [console.error],\n            componentregister: [],\n            destroy: [],\n            ...handlers\n        }\n    }\n}\n\nexport interface EventsTypes {\n    warn: string | Error;\n    error: string | Error;\n    componentregister: Component;\n    destroy: void;\n}","import { listenWindow } from './utils';\n\nexport class Drag {\n\n    pointerStart: [number, number] | null;\n    el: HTMLElement;\n    destroy: () => void;\n\n    constructor(\n        el: HTMLElement,\n        private onTranslate = (_x: number, _y: number, _e: PointerEvent) => {},\n        private onStart = (_e: PointerEvent) => {},\n        private onDrag = (_e: PointerEvent) => {}\n    ) {\n        this.pointerStart = null;\n        this.el = el;\n\n        this.el.style.touchAction = 'none';\n        this.el.addEventListener('pointerdown', this.down.bind(this));\n\n        const destroyMove = listenWindow('pointermove', this.move.bind(this));\n        const destroyUp = listenWindow('pointerup', this.up.bind(this));\n\n        this.destroy = () => { destroyMove(); destroyUp(); }\n    }\n\n    down(e: PointerEvent) {\n        if ((e.pointerType === 'mouse') && (e.button !== 0)) return;\n        e.stopPropagation();\n        this.pointerStart = [e.pageX, e.pageY]\n\n        this.onStart(e);\n    }\n\n    move(e: PointerEvent) {\n        if (!this.pointerStart) return;\n        e.preventDefault();\n\n        const [x, y] = [e.pageX, e.pageY]\n\n        const delta = [x - this.pointerStart[0], y - this.pointerStart[1]];\n\n        const zoom = this.el.getBoundingClientRect().width / this.el.offsetWidth;\n\n        this.onTranslate(delta[0] / zoom, delta[1] / zoom, e);\n    }\n\n    up(e: PointerEvent) {\n        if (!this.pointerStart) return;\n\n        this.pointerStart = null;\n        this.onDrag(e);\n    }\n}\n","import { listenWindow } from './utils';\n\nexport class Zoom {\n\n    el: HTMLElement;\n    intensity: number;\n    onzoom: Function;\n    previous: { cx: number; cy: number; distance: number } | null = null;\n\n    pointers: PointerEvent[] = [];\n    destroy: () => void;\n\n    constructor(container: HTMLElement, el: HTMLElement, intensity: number, onzoom: Function) {\n        this.el = el;\n        this.intensity = intensity;\n        this.onzoom = onzoom;\n\n        container.addEventListener('wheel', this.wheel.bind(this));\n        container.addEventListener('pointerdown', this.down.bind(this));\n        container.addEventListener('dblclick', this.dblclick.bind(this));\n\n        const destroyMove = listenWindow('pointermove', this.move.bind(this));\n        const destroyUp = listenWindow('pointerup', this.end.bind(this));\n        const destroyCancel = listenWindow('pointercancel', this.end.bind(this));\n\n        this.destroy = () => { destroyMove(); destroyUp(); destroyCancel(); }\n    }\n\n    get translating() { // is translating while zoom (works on multitouch)\n        return this.pointers.length >= 2;\n    }\n\n    wheel(e: WheelEvent) {\n        e.preventDefault();\n\n        const rect = this.el.getBoundingClientRect();\n        const isNegative = e.deltaY < 0;\n        const delta = isNegative ? this.intensity : - this.intensity;\n        const ox = (rect.left - e.clientX) * delta;\n        const oy = (rect.top - e.clientY) * delta;\n\n        this.onzoom(delta, ox, oy, 'wheel');\n    }\n\n    touches() {\n        const e = { touches: this.pointers }\n        const [x1, y1] = [e.touches[0].clientX, e.touches[0].clientY];\n        const [x2, y2] = [e.touches[1].clientX, e.touches[1].clientY];\n\n        const distance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n\n        return {\n            cx: (x1 + x2)/2,\n            cy: (y1 + y2)/2,\n            distance\n        };\n    }\n\n    down(e: PointerEvent) {\n        this.pointers.push(e);\n    }\n\n    move(e: PointerEvent) {\n        this.pointers = this.pointers.map(p => p.pointerId === e.pointerId ? e : p)\n        if (!this.translating) return;\n\n        const rect = this.el.getBoundingClientRect();\n\n        const { cx, cy, distance } = this.touches();\n\n        if (this.previous !== null) {\n            const delta = distance / this.previous.distance - 1;\n\n            const ox = (rect.left - cx) * delta;\n            const oy = (rect.top - cy) * delta;\n\n            this.onzoom(delta, ox - (this.previous.cx - cx), oy - (this.previous.cy - cy), 'touch');\n        }\n        this.previous = { cx, cy, distance };\n    }\n\n    end(e: PointerEvent) {\n        this.previous = null;\n        this.pointers = this.pointers.filter(p => p.pointerId !== e.pointerId)\n    }\n\n    dblclick(e: MouseEvent) {\n        e.preventDefault();\n\n        const rect = this.el.getBoundingClientRect();\n        const delta = 4 * this.intensity;\n\n        const ox = (rect.left - e.clientX) * delta;\n        const oy = (rect.top - e.clientY) * delta;\n\n        this.onzoom(delta, ox, oy, 'dblclick');\n    }\n}\n","import { Drag } from './drag';\nimport { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\nimport { Zoom } from './zoom';\n\nexport interface Transform { k: number; x: number; y: number }\nexport interface Mouse { x: number; y: number }\nexport type ZoomSource = 'wheel' | 'touch' | 'dblclick';\n\nexport class Area extends Emitter<EventsTypes> {\n\n    el: HTMLElement;\n    container: HTMLElement;\n    transform: Transform = { k: 1, x: 0, y: 0 };\n    mouse: Mouse = { x: 0, y: 0 }\n    \n    private _startPosition: Transform | null = null\n    private _zoom: Zoom;\n    private _drag: Drag;\n\n    constructor(container: HTMLElement, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n        \n        const el = this.el = document.createElement('div');\n\n        this.container = container;\n        el.style.transformOrigin = '0 0';\n\n        this._zoom = new Zoom(container, el, 0.1, this.onZoom.bind(this));\n        this._drag = new Drag(container, this.onTranslate.bind(this), this.onStart.bind(this));\n\n        emitter.on('destroy', () => {\n            this._zoom.destroy();\n            this._drag.destroy();\n        });\n\n        this.container.addEventListener('pointermove', this.pointermove.bind(this));\n\n        this.update();\n    }\n\n    update() {\n        const t = this.transform;\n\n        this.el.style.transform = `translate(${t.x}px, ${t.y}px) scale(${t.k})`;\n    }\n\n    pointermove(e: PointerEvent) {\n        const { clientX, clientY } = e;\n        const rect = this.el.getBoundingClientRect();\n        const x = clientX - rect.left;\n        const y = clientY - rect.top;\n        const k = this.transform.k;\n        \n        this.mouse = { x: x / k, y: y / k };\n        this.trigger('mousemove', { ...this.mouse }); // TODO rename on `pointermove`\n    }\n\n    onStart() {\n        this._startPosition = { ...this.transform };\n    }\n\n    onTranslate(dx: number, dy: number) {\n        if (this._zoom.translating) return; // lock translation while zoom on multitouch\n        if (this._startPosition) this.translate(this._startPosition.x + dx, this._startPosition.y + dy);\n    }\n\n    onZoom(delta: number, ox: number, oy: number, source: ZoomSource) {\n        this.zoom(this.transform.k * (1 + delta), ox, oy, source);\n\n        this.update();\n    }\n\n    translate(x: number, y: number) {\n        const params = { transform: this.transform, x, y };\n\n        if (!this.trigger('translate', params)) return;\n\n        this.transform.x = params.x;\n        this.transform.y = params.y;\n\n        this.update();\n        this.trigger('translated');\n    }\n\n    zoom(zoom: number, ox = 0, oy = 0, source: ZoomSource) {\n        const k = this.transform.k;\n        const params = { transform: this.transform, zoom, source };\n\n        if (!this.trigger('zoom', params)) return;\n        \n        const d = (k - params.zoom) / ((k - zoom) || 1);\n\n        this.transform.k = params.zoom || 1;\n        this.transform.x += ox * d;\n        this.transform.y += oy * d;\n\n        this.update();\n        this.trigger('zoomed', { source });\n    }\n\n    appendChild(el: HTMLElement) {\n        this.el.appendChild(el)\n    }\n\n    removeChild(el: HTMLElement) {\n        this.el.removeChild(el)\n    }\n}","import { Connection } from '../connection';\nimport { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\nimport { NodeView } from './node';\n\nexport class ConnectionView extends Emitter<EventsTypes> {\n\n    connection: Connection;\n    inputNode: NodeView;\n    outputNode: NodeView;\n    el: HTMLElement;\n\n    constructor(connection: Connection, inputNode: NodeView, outputNode: NodeView, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n        this.connection = connection;\n        this.inputNode = inputNode;\n        this.outputNode = outputNode;\n\n        this.el = document.createElement('div');\n        this.el.style.position = 'absolute';\n        this.el.style.zIndex = '-1';\n\n        this.trigger('renderconnection', {\n            el: this.el,\n            connection: this.connection,\n            points: this.getPoints()\n        });\n    }\n\n    getPoints() {\n        const { input, output } = this.connection\n\n        if (this.inputNode.hasSocket(input) && this.outputNode.hasSocket(output)) {\n            const [x1, y1] = this.outputNode.getSocketPosition(output);\n            const [x2, y2] = this.inputNode.getSocketPosition(input);\n\n            return [x1, y1, x2, y2];\n        }\n\n        return [0, 0, 0, 0]\n    }\n\n    update() {\n        this.trigger('updateconnection', {\n            el: this.el,\n            connection: this.connection,\n            points: this.getPoints()\n        });\n    }\n}\n","import { Control } from '../control';\nimport { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\n\nexport class ControlView extends Emitter<EventsTypes> {\n\n    constructor(el: HTMLElement, control: Control, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n        this.trigger('rendercontrol', { el, control });\n    }\n}","import { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\nimport { IO } from '../io';\nimport { Node } from '../node';\n\nexport class SocketView extends Emitter<EventsTypes> {\n\n    el: HTMLElement;\n    type: string;\n    io: IO;\n    node: Node;\n\n    constructor(el: HTMLElement, type: string, io: IO, node: Node, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n        this.el = el;\n        this.type = type;\n        this.io = io;\n        this.node = node;\n\n        this.trigger('rendersocket', { el, [type]: this.io, socket: io.socket });\n    }\n\n    getPosition({ position }: { position: number[] }): [number, number] {\n        const el = this.el;\n\n        if (this.node.collapsed) {\n            let isOutput = false;\n            const customHackedOffsetX = 50;\n\n            if (this.io.node) {\n                isOutput = this.io.socket.name === 'output'\n            }\n            // @ts-ignore\n            // the middle of the node component\n            const posY = document.getElementById(this.node.name.toLowerCase() + '-' + this.node.id).offsetHeight / 2\n\n            if (isOutput) {\n                // @ts-ignore\n                const posXOutput = document.getElementById('details-' + this.node.id).offsetWidth - customHackedOffsetX\n\n                return [\n                    // @ts-ignore\n                    position[0] + posXOutput,\n                    position[1] + posY\n                ]\n            }\n\n            return [\n                position[0] + customHackedOffsetX,\n                // @ts-ignore\n                position[1] + posY\n            ]\n        }\n        if (this.node.inputsCollapsed) {\n            let isOutput = false;\n            const customHackedOffsetX = 50;\n            const customHackedOffsetY = -10;\n\n            if (this.io.node) {\n                isOutput = this.io.socket.name === 'output'\n            }\n            if (!isOutput) {\n                // @ts-ignore\n                // the middle of the inputs\n                const posY = document.getElementById('node-inputs-' + this.node.id).offsetHeight + document.getElementById('node-summary-' + this.node.id).offsetHeight + customHackedOffsetY\n\n                return [\n                    position[0] + customHackedOffsetX,\n                    // @ts-ignore\n                    position[1] + posY\n                ]\n            }\n        }\n        if (this.node.outputsCollapsed) {\n            let isOutput = false;\n            const customHackedOffsetX = 47;\n            const customHackedOffsetY = 0;\n\n            if (this.io.node) {\n                isOutput = this.io.socket.name === 'output'\n            }\n            if (isOutput) {\n                // @ts-ignore\n                // the middle of the outputs\n                const posY = document.getElementById('company-' + this.node.id).offsetHeight + customHackedOffsetY - document.getElementById('node-footer-' + this.node.id).offsetHeight - document.getElementById('node-outputs-' + this.node.id).offsetHeight / 2\n                // @ts-ignore\n                const posXOutput = document.getElementById('details-' + this.node.id).offsetWidth - customHackedOffsetX\n\n                return [\n                    position[0] + posXOutput,\n                    // @ts-ignore\n                    position[1] + posY\n                ]\n            }\n        }\n        return [\n            position[0] + el.offsetLeft + el.offsetWidth / 2,\n            position[1] + el.offsetTop + el.offsetHeight / 2\n        ]\n    }\n}","import { Component } from '../engine/component';\nimport { Control } from '../control';\nimport { ControlView } from './control';\nimport { Drag } from './drag';\nimport { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\nimport { IO } from '../io';\nimport { Node } from '../node';\nimport { SocketView } from './socket';\n\nexport class NodeView extends Emitter<EventsTypes> {\n\n    node: Node;\n    component: Component;\n    sockets = new Map<IO, SocketView>();\n    controls = new Map<Control, ControlView>();\n\n    el: HTMLElement;\n    private _startPosition: number[] = [];\n    private _drag: Drag;\n\n    constructor(node: Node, component: Component, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n\n        this.node = node;\n        this.component = component;\n        this.el = document.createElement('div');\n        this.el.style.position = 'absolute';\n\n        this.el.addEventListener('contextmenu', e => this.trigger('contextmenu', { e, node: this.node }));\n\n        this._drag = new Drag(this.el, this.onTranslate.bind(this), this.onSelect.bind(this), () => {\n            this.trigger('nodedraged', node);\n            this.trigger('nodedragged', node);\n        });\n\n        this.trigger('rendernode', {\n            el: this.el,\n            node,\n            component: component.data,\n            bindSocket: this.bindSocket.bind(this),\n            bindControl: this.bindControl.bind(this)\n        });\n\n        this.update();\n    }\n\n    clearSockets() {\n        const ios: IO[] = [ ...this.node.inputs.values(), ...this.node.outputs.values()];\n\n        this.sockets.forEach(s => {\n            if (!ios.includes(s.io)) this.sockets.delete(s.io);\n        });\n    }\n\n    bindSocket(el: HTMLElement, type: string, io: IO) {\n        this.clearSockets();\n        this.sockets.set(io, new SocketView(el, type, io, this.node, this));\n    }\n\n    bindControl(el: HTMLElement, control: Control) {\n        this.controls.set(control, new ControlView(el, control, this));\n    }\n\n    hasSocket(io: IO) {\n        return this.sockets.has(io)\n    }\n\n    getSocketPosition(io: IO) {\n        const socket = this.sockets.get(io);\n\n        if (!socket) throw new Error(`Socket not found for ${io.name} with key ${io.key}`);\n\n        return socket.getPosition(this.node);\n    }\n\n    onSelect(e: MouseEvent) {\n        const payload = { node: this.node, accumulate: e.ctrlKey, e };\n\n        this.onStart();\n        this.trigger('multiselectnode', payload);\n        this.trigger('selectnode', payload);\n    }\n\n    onStart() {\n        this._startPosition = [...this.node.position];\n    }\n\n    onTranslate(dx: number, dy: number) {\n        this.trigger('translatenode', { node: this.node, dx, dy });\n    }\n\n    onDrag(dx: number, dy: number) {\n        const x = this._startPosition[0] + dx;\n        const y = this._startPosition[1] + dy;\n\n        this.translate(x, y);\n    }\n\n    translate(x: number, y: number) {\n        const node = this.node;\n        const params = { node, x, y };\n\n        if (!this.trigger('nodetranslate', params)) return;\n\n        const [px, py] = node.position;\n        const prev: [number, number] = [px, py];\n\n        node.position[0] = params.x;\n        node.position[1] = params.y;\n\n        this.update();\n        this.trigger('nodetranslated', { node, prev });\n    }\n\n    update() {\n        const [x, y] = this.node.position;\n\n        this.el.style.transform = `translate(${x}px, ${y}px)`;\n    }\n\n    remove() {\n\n    }\n\n    destroy() {\n        this._drag.destroy();\n    }\n}\n","import { Area } from './area';\nimport { Component } from '../engine/component';\nimport { Connection } from '../connection';\nimport { ConnectionView } from './connection';\nimport { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\nimport { Node } from '../node';\nimport { NodeView } from './node';\nimport { listenWindow } from './utils';\n\nexport class EditorView extends Emitter<EventsTypes> {\n\n    container: HTMLElement;\n    components: Map<string, Component>;\n    nodes = new Map<Node, NodeView>();\n    connections = new Map<Connection, ConnectionView>();\n    area: Area;\n\n    // eslint-disable-next-line max-statements\n    constructor(container: HTMLElement, components: Map<string, Component>, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n\n        this.container = container;\n        this.components = components;\n\n        this.container.style.overflow = 'hidden';\n\n        this.container.addEventListener('click', this.click.bind(this));\n        this.container.addEventListener('contextmenu', e => this.trigger('contextmenu', { e, view: this }));\n        emitter.on('destroy', listenWindow('resize', this.resize.bind(this)));\n        emitter.on('destroy', () => this.nodes.forEach(view => view.destroy()));\n\n        this.on('nodetranslated', this.updateConnections.bind(this));\n        this.on('rendersocket', ({ input, output }) => {\n            const connections = Array.from(this.connections.entries())\n            const relatedConnections = connections.filter(([connection]) => {\n                return connection.input === input || connection.output === output\n            })\n\n            relatedConnections.forEach(([_, view]) => requestAnimationFrame(() => view.update()))\n        })\n\n        this.area = new Area(container, this);\n        this.container.appendChild(this.area.el);\n    }\n\n    addNode(node: Node) {\n        const component = this.components.get(node.name);\n\n        if (!component) throw new Error(`Component ${node.name} not found`);\n\n        const nodeView = new NodeView(node, component, this);\n\n        this.nodes.set(node, nodeView);\n        this.area.appendChild(nodeView.el);\n    }\n\n    removeNode(node: Node) {\n        const nodeView = this.nodes.get(node);\n\n        this.nodes.delete(node);\n        if (nodeView) {\n            this.area.removeChild(nodeView.el);\n            nodeView.destroy();\n        }\n    }\n\n    addConnection(connection: Connection) {\n        if (!connection.input.node || !connection.output.node)\n            throw new Error('Connection input or output not added to node');\n\n        const viewInput = this.nodes.get(connection.input.node);\n        const viewOutput = this.nodes.get(connection.output.node);\n\n        if (!viewInput || !viewOutput)\n            throw new Error('View node not found for input or output');\n\n        const connView = new ConnectionView(connection, viewInput, viewOutput, this);\n\n        this.connections.set(connection, connView);\n        this.area.appendChild(connView.el);\n    }\n\n    removeConnection(connection: Connection) {\n        const connView = this.connections.get(connection);\n\n        this.connections.delete(connection);\n        if (connView)\n            this.area.removeChild(connView.el);\n    }\n\n    updateConnections({ node }: { node: Node }) {\n        node.getConnections().forEach(conn => {\n            const connView = this.connections.get(conn);\n\n            if (!connView) throw new Error('Connection view not found');\n\n            connView.update();\n        });\n    }\n\n    resize() {\n        const { container } = this;\n\n        if (!container.parentElement)\n            throw new Error('Container doesn\\'t have parent element');\n\n        const width = container.parentElement.clientWidth;\n        const height = container.parentElement.clientHeight;\n\n        container.style.width = width + 'px';\n        container.style.height = height + 'px';\n    }\n\n    click(e: Event) {\n        const container = this.container;\n\n        if (container !== e.target) return;\n        if (!this.trigger('click', { e, container })) return;\n    }\n}\n","import { Node } from './node';\n\nexport class Selected {\n\n    list: Node[] = [];\n\n    add(item: Node, accumulate = false) {\n        if (!accumulate)\n            this.list = [item]; \n        else if (!this.contains(item))\n            this.list.push(item);   \n    }\n\n    clear() {\n        this.list = [];\n    }\n\n    remove(item: Node) {\n        this.list.splice(this.list.indexOf(item), 1);\n    }\n\n    contains(item: Node) {\n        return this.list.indexOf(item) !== -1;\n    }\n\n    each(callback: (n: Node, index: number) => void) {\n        this.list.forEach(callback);\n    }\n}","import { Component } from './component';\nimport { Connection } from './connection';\nimport { Control } from './control';\nimport { Data } from './core/data';\nimport { EditorView } from './view';\nimport { Input } from './input';\nimport { Node } from './node';\nimport { Output } from './output';\nimport { Socket } from './socket';\nimport { EventsTypes as DefaultEventsTypes, Events } from './core/events';\nimport { Mouse, Transform, ZoomSource } from './view/area';\n\nexport class EditorEvents extends Events {\n\n    constructor() {\n        super({\n            nodecreate: [],\n            nodecreated: [],\n            noderemove: [],\n            noderemoved: [],\n            connectioncreate: [],\n            connectioncreated: [],\n            connectionremove: [],\n            connectionremoved: [],\n            translatenode: [],\n            nodetranslate: [],\n            nodetranslated: [],\n            nodedraged: [],\n            nodedragged: [],\n            selectnode: [],\n            multiselectnode: [],\n            nodeselect: [],\n            nodeselected: [],\n            rendernode: [],\n            rendersocket: [],\n            rendercontrol: [],\n            renderconnection: [],\n            updateconnection: [],\n            keydown: [],\n            keyup: [],\n            translate: [],\n            translated: [],\n            zoom: [],\n            zoomed: [],\n            click: [],\n            mousemove: [],\n            contextmenu: [],\n            import: [],\n            export: [],\n            process: [],\n            clear: []\n        });\n    }    \n}\n\nexport interface EventsTypes extends DefaultEventsTypes {\n    componentregister: Component;\n    nodecreate: Node;\n    nodecreated: Node;\n    noderemove: Node;\n    noderemoved: Node;\n    connectioncreate: { input: Input; output: Output };\n    connectioncreated: Connection;\n    connectionremove: Connection;\n    connectionremoved: Connection;\n    translatenode: { node: Node; dx: number; dy: number };\n    nodetranslate: { node: Node; x: number; y: number };\n    nodetranslated: { node: Node; prev: [number, number] };\n    nodedraged: Node;\n    nodedragged: Node;\n    selectnode: {\n        node: Node;\n        accumulate: boolean;\n    };\n    multiselectnode: {\n        node: Node;\n        accumulate: boolean;\n        e: MouseEvent;\n    };\n    nodeselect: Node;\n    nodeselected: Node;\n    rendernode: {\n        el: HTMLElement;\n        node: Node;\n        component: object;\n        bindSocket: Function;\n        bindControl: Function;\n    };\n    rendersocket: {\n        el: HTMLElement;\n        input?: Input;\n        output?: Output;\n        socket: Socket;\n    };\n    rendercontrol: {\n        el: HTMLElement;\n        control: Control;\n    };\n    renderconnection: {\n        el: HTMLElement;\n        connection: Connection;\n        points: number[];\n    };\n    updateconnection: {\n        el: HTMLElement;\n        connection: Connection;\n        points: number[];\n    };\n    keydown: KeyboardEvent;\n    keyup: KeyboardEvent;\n    translate: {\n        transform: Transform;\n        x: number;\n        y: number;\n    };\n    translated: void;\n    zoom: {\n        transform: Transform;\n        zoom: number;\n        source: ZoomSource;\n    };\n    zoomed: {\n        source: ZoomSource;\n    };\n    click: {\n        e: Event;\n        container: HTMLElement;\n    };\n    mousemove: Mouse;\n    contextmenu: {\n        e: MouseEvent;\n        view?: EditorView;\n        node?: Node;\n    };\n    import: Data;\n    export: Data;\n    process: void;\n    clear: void;\n}\n","import { Component } from './component';\nimport { Connection } from './connection';\nimport { Context } from './core/context';\nimport { Data } from './core/data';\nimport { EditorView } from './view/index';\nimport { Input } from './input';\nimport { Node } from './node';\nimport { Output } from './output';\nimport { Selected } from './selected';\nimport { Validator } from './core/validator';\nimport { listenWindow } from './view/utils';\nimport { EditorEvents, EventsTypes } from './events';\n\nexport class NodeEditor extends Context<EventsTypes> {\n\n    nodes: Node[] = [];\n    selected = new Selected();\n    view: EditorView;\n\n    constructor(id: string, container: HTMLElement) {\n        super(id, new EditorEvents());\n\n        this.view = new EditorView(container, this.components, this);\n\n        this.on('destroy', listenWindow('keydown', e => this.trigger('keydown', e)));\n        this.on('destroy', listenWindow('keyup', e => this.trigger('keyup', e)));\n\n        this.on('selectnode', ({ node, accumulate }) => this.selectNode(node, accumulate));\n        this.on('nodeselected', () => this.selected.each(n => {\n            const nodeView = this.view.nodes.get(n);\n\n            nodeView && nodeView.onStart()\n        }));\n        this.on('translatenode', ({ dx, dy }) => this.selected.each(n => {\n            const nodeView = this.view.nodes.get(n);\n\n            nodeView && nodeView.onDrag(dx, dy)\n        }));\n    }\n\n    addNode(node: Node) {\n        if (!this.trigger('nodecreate', node)) return;\n\n        this.nodes.push(node);\n        this.view.addNode(node);\n\n        this.trigger('nodecreated', node);\n    }\n\n    removeNode(node: Node) {\n        if (!this.trigger('noderemove', node)) return;\n\n        node.getConnections().forEach(c => this.removeConnection(c));\n\n        this.nodes.splice(this.nodes.indexOf(node), 1);\n        this.view.removeNode(node);\n\n        this.trigger('noderemoved', node);\n    }\n\n    connect(output: Output, input: Input, data: unknown = {}) {\n        if (!this.trigger('connectioncreate', { output, input })) return;\n\n        try {\n            const connection = output.connectTo(input);\n\n            connection.data = data;\n            this.view.addConnection(connection);\n\n            this.trigger('connectioncreated', connection);\n        } catch (e) {\n            this.trigger('warn', e as Error)\n        }\n    }\n\n    removeConnection(connection: Connection) {\n        if (!this.trigger('connectionremove', connection)) return;\n\n        this.view.removeConnection(connection);\n        connection.remove();\n\n        this.trigger('connectionremoved', connection);\n    }\n\n    selectNode(node: Node, accumulate = false) {\n        if (this.nodes.indexOf(node) === -1)\n            throw new Error('Node not exist in list');\n\n        if (!this.trigger('nodeselect', node)) return;\n\n        this.selected.add(node, accumulate);\n\n        this.trigger('nodeselected', node);\n    }\n\n    getComponent(name: string) {\n        const component = this.components.get(name);\n\n        if (!component)\n            throw `Component ${name} not found`;\n\n        return component as Component;\n    }\n\n    register(component: Component) {\n        super.register(component)\n        component.editor = this;\n    }\n\n    clear() {\n        [...this.nodes].forEach(node => this.removeNode(node));\n        this.trigger('clear');\n    }\n\n    toJSON() {\n        const data: Data = { id: this.id, nodes: {} };\n\n        this.nodes.forEach(node => data.nodes[node.id] = node.toJSON());\n        this.trigger('export', data);\n        return data;\n    }\n\n    beforeImport(json: Data) {\n        const checking = Validator.validate(this.id, json);\n\n        if (!checking.success) {\n            this.trigger('warn', checking.msg);\n            return false;\n        }\n\n        this.silent = true;\n        this.clear();\n        this.trigger('import', json);\n        return true;\n    }\n\n    afterImport() {\n        this.silent = false;\n        return true;\n    }\n\n    async fromJSON(json: Data) {\n        if (!this.beforeImport(json)) return false;\n        const nodes: {[key: string]: Node} = {};\n\n        try {\n            await Promise.all(Object.keys(json.nodes).map(async id => {\n                const node = json.nodes[id];\n                const component = this.getComponent(node.name);\n\n                nodes[id] = await component.build(Node.fromJSON(node));\n                this.addNode(nodes[id]);\n            }));\n\n            Object.keys(json.nodes).forEach(id => {\n                const jsonNode = json.nodes[id];\n                const node = nodes[id];\n\n                Object.keys(jsonNode.outputs).forEach(key => {\n                    const outputJson = jsonNode.outputs[key];\n\n                    outputJson.connections.forEach(jsonConnection => {\n                        const nodeId = jsonConnection.node;\n                        const data = jsonConnection.data;\n                        const targetOutput = node.outputs.get(key);\n                        const targetInput = nodes[nodeId].inputs.get(jsonConnection.input);\n\n                        if (!targetOutput || !targetInput) {\n                            return this.trigger('error', `IO not found for node ${node.id}`);\n                        }\n\n                        this.connect(targetOutput, targetInput, data);\n                    });\n                });\n\n            });\n        } catch (e) {\n            this.trigger('warn', e as Error);\n            return !this.afterImport();\n        }\n\n        return this.afterImport();\n    }\n}\n","import { Connection } from './connection';\nimport { IO } from './io';\nimport { Input } from './input';\nimport { OutputData } from './core/data';\nimport { Socket } from './socket';\n\nexport class Output extends IO {\n\n    constructor(key: string, title: string, socket: Socket, multiConns = true) {\n        super(key, title, socket, multiConns);\n    }\n\n    hasConnection() {\n        return this.connections.length > 0;\n    }\n\n    connectTo(input: Input) {\n        if (!this.socket.compatibleWith(input.socket))\n            throw new Error('Sockets not compatible');\n        if (!input.multipleConnections && input.hasConnection())\n            throw new Error('Input already has one connection');\n        if (!this.multipleConnections && this.hasConnection())\n            throw new Error('Output already has one connection');\n\n        const connection = new Connection(this, input);\n\n        this.connections.push(connection);\n        return connection;\n    }\n\n    connectedTo(input: Input) {\n        return this.connections.some((item) => {\n            return item.input === input;\n        });\n    }\n\n    toJSON(): OutputData {\n        return {\n            'connections': this.connections.map(c => {\n                if (!c.input.node) throw new Error('Node not added to Input');\n\n                return {\n                    node: c.input.node.id,\n                    input: c.input.key,\n                    data: c.data\n                }\n            })\n        };\n    }\n}\n","export class Socket {\n\n    name: string;\n    data: unknown;\n    compatible: Socket[] = [];\n\n    constructor(name: string, data = {}) {\n        this.name = name;\n        this.data = data;\n        this.compatible = [];\n    }\n\n    combineWith(socket: Socket) {\n        this.compatible.push(socket);\n    }\n\n    compatibleWith(socket: Socket) {\n        return this === socket || this.compatible.includes(socket);\n    }\n}","import { InputConnectionData, NodeData, NodesData } from '../core/data';\n\nfunction intersect<T>(array1: T[], array2: T[]) {\n    return array1.filter(value => -1 !== array2.indexOf(value));\n}\n\nexport class Recursion {\n\n    nodes: NodesData;\n\n    constructor(nodes: NodesData) {\n        this.nodes = nodes;\n    }\n\n    extractInputNodes(node: NodeData): NodeData[] {\n        return Object.keys(node.inputs).reduce((acc: NodeData[], key: string) => {\n            const { connections } = node.inputs[key];\n            const nodesData = (connections || []).reduce((b: NodeData[], c: InputConnectionData) => {\n                return [...b, this.nodes[c.node]];\n            }, []);\n\n            return [...acc, ...nodesData]\n        }, []);\n    }\n\n    findSelf(list: NodeData[], inputNodes: NodeData[]): NodeData | null {\n        const inters = intersect<NodeData>(list, inputNodes);\n\n        if (inters.length)\n            return inters[0];\n\n        for (const node of inputNodes) {\n            const l = [node, ...list];\n            const inter = this.findSelf(l, this.extractInputNodes(node));\n\n            if (inter)\n                return inter;\n        }\n\n        return null;\n    }\n\n    detect(): NodeData | null {\n        const nodesArr = Object.keys(this.nodes).map(id => this.nodes[id]);\n\n        for (const node of nodesArr) {\n            const inters = this.findSelf([node], this.extractInputNodes(node));\n\n            if (inters)\n                return inters;\n        }\n\n        return null;\n    }\n}\n","export const State = { AVAILABLE: 0, PROCESSED: 1, ABORT: 2 }","import { Events } from '../core/events';\n\nexport class EngineEvents extends Events {\n\n    constructor() {\n        super({});\n    }    \n}\nexport interface EventsTypes {\n}","import { Component } from './component';\nimport { Context } from '../core/context';\nimport { Recursion } from './recursion';\nimport { State } from './state';\nimport { Validator } from '../core/validator';\nimport { Data, NodeData, WorkerOutputs } from '../core/data';\nimport { EngineEvents, EventsTypes } from './events';\nexport { Component, Recursion };\n\ninterface EngineNode extends NodeData {\n    busy: boolean;\n    unlockPool: (() => void)[];\n    outputData: WorkerOutputs;\n}\n\nexport class Engine extends Context<EventsTypes> {\n\n    args: unknown[] = [];\n    data: Data | null = null;\n    state = State.AVAILABLE;\n    forwarded = new Set();\n    onAbort = () => { };\n\n    constructor(id: string) {\n        super(id, new EngineEvents());\n    }\n\n    public clone() {\n        const engine = new Engine(this.id);\n\n        this.components.forEach(c => engine.register(c));\n\n        return engine;\n    }\n\n    async throwError (message: string, data: unknown = null) {\n        await this.abort();\n        this.trigger('error', { message, data });\n        this.processDone();\n\n        return 'error';\n    }\n\n    private processStart() {\n        if (this.state === State.AVAILABLE) {\n            this.state = State.PROCESSED;\n            return true;\n        }\n\n        if (this.state === State.ABORT) {\n            return false;\n        }\n\n        console.warn(`The process is busy and has not been restarted.\n                Use abort() to force it to complete`);\n        return false;\n    }\n\n    private processDone() {\n        const success = this.state !== State.ABORT;\n\n        this.state = State.AVAILABLE;\n\n        if (!success) {\n            this.onAbort();\n            this.onAbort = () => { }\n        }\n\n        return success;\n    }\n\n    public async abort() {\n        return new Promise<void>(ret => {\n            if (this.state === State.PROCESSED) {\n                this.state = State.ABORT;\n                this.onAbort = ret;\n            }\n            else if (this.state === State.ABORT) {\n                this.onAbort();\n                this.onAbort = ret;\n            }\n            else\n                ret();\n        });\n    }\n\n    private async lock(node: EngineNode) {\n        return new Promise<void>(res => {\n            node.unlockPool = node.unlockPool || [];\n            if (node.busy && !node.outputData)\n                node.unlockPool.push(res);\n            else\n                res();\n\n            node.busy = true;\n        });\n    }\n\n    unlock(node: EngineNode) {\n        node.unlockPool.forEach(a => a());\n        node.unlockPool = [];\n        node.busy = false;\n    }\n\n    private async extractInputData(node: NodeData) {\n        const obj: {[id: string]: any} = {};\n\n        for (const key of Object.keys(node.inputs)) {\n            const input = node.inputs[key];\n            const conns = input.connections;\n            const connData = await Promise.all(conns.map(async (c) => {\n                const prevNode = (this.data as Data).nodes[c.node];\n\n                const outputs = await this.processNode(prevNode as EngineNode);\n\n                if (!outputs)\n                    this.abort();\n                else\n                    return outputs[c.output];\n            }));\n\n            obj[key] = connData;\n        }\n\n        return obj;\n    }\n\n    private async processWorker(node: NodeData) {\n        const inputData = await this.extractInputData(node);\n        const component = this.components.get(node.name) as Component;\n        const outputData = {};\n\n        try {\n            await component.worker(node, inputData, outputData, ...this.args);\n        } catch (e) {\n            this.abort();\n            this.trigger('warn', e as Error);\n        }\n\n        return outputData;\n    }\n\n    private async processNode(node: EngineNode) {\n        if (this.state === State.ABORT || !node)\n            return null;\n\n        await this.lock(node);\n\n        if (!node.outputData) {\n            node.outputData = await this.processWorker(node);\n        }\n\n        this.unlock(node);\n        return node.outputData;\n    }\n\n    private async forwardProcess(node: NodeData) {\n        if (this.state === State.ABORT)\n            return null;\n\n        return await Promise.all(Object.keys(node.outputs).map(async (key) => {\n            const output = node.outputs[key];\n            return await Promise.all(output.connections.map(async (c) => {\n                const nextNode = (this.data as Data).nodes[c.node];\n                if(!this.forwarded.has(nextNode)) {\n                    this.forwarded.add(nextNode);\n                    await this.processNode(nextNode as EngineNode);\n                    await this.forwardProcess(nextNode);\n                }\n            }));\n        }));\n    }\n\n    copy(data: Data) {\n        data = Object.assign({}, data);\n        data.nodes = Object.assign({}, data.nodes);\n\n        Object.keys(data.nodes).forEach(key => {\n            data.nodes[key] = Object.assign({}, data.nodes[key])\n        });\n        return data;\n    }\n\n    async validate(data: Data) {\n        const checking = Validator.validate(this.id, data);\n        const recursion = new Recursion(data.nodes);\n\n        if (!checking.success)\n            return await this.throwError(checking.msg);\n\n        const recurrentNode = recursion.detect();\n\n        if (recurrentNode)\n            return await this.throwError('Recursion detected', recurrentNode);\n\n        return true;\n    }\n\n    private async processStartNode(id: string | number | null) {\n        if (!id) return;\n\n        const startNode = (this.data as Data).nodes[id];\n\n        if (!startNode)\n            return await this.throwError('Node with such id not found');\n\n        await this.processNode(startNode as EngineNode);\n        await this.forwardProcess(startNode);\n    }\n\n    private async processUnreachable() {\n        const data = this.data as Data;\n\n        for (const i in data.nodes) { // process nodes that have not been reached\n            const node = data.nodes[i] as EngineNode;\n\n            if (typeof node.outputData === 'undefined') {\n                await this.processNode(node);\n                await this.forwardProcess(node);\n            }\n        }\n    }\n\n    async process<T extends unknown[]>(data: Data, startId: number | string | null = null, ...args: T) {\n        if (!this.processStart()) return;\n        if (!this.validate(data)) return;\n\n        this.data = this.copy(data);\n        this.args = args;\n        this.forwarded = new Set();\n\n        await this.processStartNode(startId);\n        await this.processUnreachable();\n\n        return this.processDone()?'success':'aborted';\n    }\n}\n","import { Component } from './component';\nimport { Connection } from './connection';\nimport { Control } from './control';\nimport { Emitter } from './core/emitter';\nimport { IO } from './io';\nimport { Input } from './input';\nimport { Node } from './node';\nimport { NodeEditor } from './editor';\nimport { Output } from './output';\nimport { Socket } from './socket';\nimport { Engine, Recursion } from './engine/index';\n\nexport { Engine, Recursion } from './engine/index';\nexport { Component } from './component';\nexport { Control } from './control';\nexport { Connection } from './connection';\nexport { Emitter } from './core/emitter';\nexport { Input } from './input';\nexport { IO } from './io';\nexport { Node } from './node';\nexport { NodeEditor } from './editor';\nexport { Output } from './output';\nexport { Socket } from './socket';\n\nexport default {\n    Engine,\n    Recursion,\n    Component,\n    Control,\n    Connection,\n    Emitter,\n    Input,\n    IO,\n    Node,\n    NodeEditor,\n    Output,\n    Socket\n}"],"names":["Component","name","Node","Map","collapsed","descriptionCollapsed","inputsCollapsed","processedCollapsed","outputsCollapsed","id","incrementId","list","item","prop","has","key","Error","this","set","control","_add","controls","parent","input","inputs","removeConnections","node","output","outputs","meta","values","reduce","arr","io","connections","reduceIO","Array","from","obj","toJSON","data","position","latestId","json","x","y","Math","max","ComponentWorker","builder","build","Connection","addConnection","removeConnection","Control","constructor","TypeError","getNode","Emitter","events","handlers","names","handler","split","forEach","_this","push","params","String","r","e","isArray","IO","socket","multiConns","multipleConnections","connection","splice","indexOf","Input","title","length","hasConnection","map","c","Validator","isValidId","nodes","Object","test","id1","id2","msg","isValidData","success","Boolean","join","Context","plugins","components","plugin","options","install","component","trigger","listenWindow","event","window","addEventListener","removeEventListener","Events","warn","console","error","componentregister","destroy","Drag","el","onTranslate","_x","_y","_e","onStart","onDrag","pointerStart","style","touchAction","down","bind","destroyMove","move","destroyUp","up","pointerType","button","stopPropagation","pageX","pageY","preventDefault","delta","zoom","getBoundingClientRect","width","offsetWidth","Zoom","container","intensity","onzoom","wheel","dblclick","end","destroyCancel","rect","deltaY","ox","left","clientX","oy","top","clientY","touches","pointers","x1","y1","x2","y2","cx","cy","distance","sqrt","pow","p","pointerId","translating","previous","filter","Area","emitter","k","document","createElement","transformOrigin","_zoom","onZoom","_drag","on","pointermove","update","t","transform","mouse","_startPosition","dx","dy","translate","source","d","appendChild","removeChild","ConnectionView","inputNode","outputNode","zIndex","points","getPoints","hasSocket","getSocketPosition","ControlView","SocketView","type","isOutput","posY","getElementById","toLowerCase","offsetHeight","posXOutput","offsetLeft","offsetTop","NodeView","onSelect","bindSocket","bindControl","ios","sockets","s","includes","_this2","clearSockets","get","getPosition","payload","accumulate","ctrlKey","prev","EditorView","overflow","click","view","resize","updateConnections","entries","requestAnimationFrame","area","nodeView","viewInput","viewOutput","connView","getConnections","conn","parentElement","clientWidth","height","clientHeight","target","Selected","contains","callback","EditorEvents","nodecreate","nodecreated","noderemove","noderemoved","connectioncreate","connectioncreated","connectionremove","connectionremoved","translatenode","nodetranslate","nodetranslated","nodedraged","nodedragged","selectnode","multiselectnode","nodeselect","nodeselected","rendernode","rendersocket","rendercontrol","renderconnection","updateconnection","keydown","keyup","translated","zoomed","mousemove","contextmenu","process","clear","NodeEditor","selectNode","selected","each","n","addNode","removeNode","connectTo","remove","add","editor","_this3","checking","validate","silent","beforeImport","Promise","all","keys","_this4","getComponent","fromJSON","jsonNode","jsonConnection","nodeId","targetOutput","targetInput","connect","afterImport","Output","compatibleWith","some","Socket","compatible","Recursion","acc","nodesData","b","inputNodes","inters","array1","array2","value","intersect","l","inter","findSelf","extractInputNodes","nodesArr","State","EngineEvents","Engine","Set","engine","register","message","abort","processDone","state","onAbort","ret","res","unlockPool","busy","outputData","a","conns","prevNode","processNode","connData","extractInputData","inputData","worker","args","lock","processWorker","unlock","nextNode","forwarded","forwardProcess","assign","recursion","throwError","recurrentNode","detect","startNode","i","startId","processStart","copy","processStartNode","processUnreachable"],"mappings":"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"}